## Data Types 数据类型

- 基本数据类型
- 日期
- 数组
- 内嵌文档
- `_id` 和 `ObjectId`

### 技术数据类型

概念上, MongoDB 文档 与 JavaScript 对象相近,因而可认为它类似于 JSON.

> JSON (http://www.json.org) 是一种简单的数据表达方式: 其规范禁用一段文字就能描述清楚,
    且仅包含 6 种数据类型. 这样的好处是: 易于理解,解析,记忆, 另一方面只有 null, boolean, 数字, 字符串,
    数组和对象 的数据类型, 所以 JSON 表达能力有一定的局限性

虽然 JSON 有强大的表现力, 但多数应用还需要一些重要的类型,
 如 JSON 没有日期类型, 这使得原本容易的日期处理变得繁琐.
另外 JSON只有一种数字类型,无法区分浮点数和整数.

**扩展**:  

MongoDB 在保留 JSON 基本键/值对的特性的基础上,添加了其他一些数据类型.在不同语言下, 这些类型确切表示有点差异.  

下面说明 MongoDB 支持的通用类型

> null

`null` 用于表示空值 或者 不存在的字段:  
```json
{"x": null}
```

> Boolean

布尔值有两个值 `true` 和 `false`

```json
{"x":true}
```

> 数值

shell 默认使用 64 位浮点数值, 因此, 以下数值在 shell 中很 "正常" 的  

```json
{"x":3.14}
{"y":3}
```

对于整形可以用 NumberInt 类(表示4个字节带符号证书) 或者 NumberLong 类(表示8字节带符号整形)  

```js
{"x": NumberInt(3)}
{"x": NumberLong(3)}
```

> 字符串

utf-8 字符串都可以表示为字符串类型的数据:  

```json
{"x":"string"}
```

> 日期

日期被存储为自新纪元以来经过的毫秒数, _不存储时区_:  

```js
{"x": new Date()}
```

> 正则表达式

查询时, 使用正则表达式作为限定条件, 语法也与 JavaScript 正则表达式语法相同:  

```js
{"x": /foobar/i}
```

> 数组

数据列表或者数据集可以表示为数组:

```json
{"x": ["a", "b", "c"]}
```

> 内嵌文档

文档可以嵌套其他文档,被嵌套的文档,作为父文档的值

```json
{"x": {"y":"foo"}}
```

> 对象id

对象 id 是一个 12字节的 ID, 是文档的唯一标识

```js
{"x", ObjectId()}
```

> 二进制数据 不常用

二进制数据是一个任意字节数的字符串,它不能直接在 shell 中使用, 如果要将非 UTF-8 字符保存到数据库中,
而进制数据是唯一的方式

> 代码 不常用

查询和文档可以包括任意 JavaScript 代码:  

```js
{"x": function() { /* coding */}}
```

### 日期

> 在 JavaScript 中, Data 类,可以用作 MongoDb 的日期类型. 创建日期对象时, 应使用 `new Date()`,
而非 `Date(...)`.
>> 将构造函数作为函数调用, 返回的是日期的字符串表示, 而非 日期( date 对象).

在 mongo shell 中的测试
```js
> d1 = Date(2016)
Sat Jul 23 2016 11:49:38 GMT+0000 (UTC)
> d2 = new Date(2016);
ISODate("1970-01-01T00:00:02.016Z")
> typeof d1;
string
> typeof d2;
object
```

shell 中 根据本地时区设置, 显示日期对象, 然而,数据库中存储的日期仅为 __新纪元以来的毫秒数__ ,并未存储时区

### 数组

数组是一组值, 它既能作为有序对象(如 列表,栈,队列), 也能作为无序对象(数据集) 来操作.  

在下面文档中, "things" 这个键的值是一个数组:  

```json
{"things": ["pie", 3.14]}
```

此案例表示, 数组可包含不同数据类型的元素.  
实际上, 常规键值 支持的所有值,都可以作为数组的值, 数组也可以嵌套数组.

文档中的数组有个奇妙的特性, 就是 MongoDb 能 "理解" 其结构, 并指导 如何 "深入" 数组内部对其 内容进行操作.  
这样就能使用 数组内容 对数组进行查询和构建索引了.

### 内嵌文档

文档可以作为键的值, 这样文档就是 _内嵌文档_ , 使用内嵌文档, 可以使数据组织方式更加自然, 不用非得存成扁平结构的键/值对.  

例如:  
用文档表示人,同时保留地址,可以内嵌 `address`   

```json
{
    "name": "theone",
    "address": {
        "street": "xi hong",
        "city": "BeiJing"
    }
}
```

> 优点:
    1. 内嵌文档可以改变处理数据的方式
    2. 可以将地址文档存到人员文档中, 使用得当,内嵌文档会使信息表示更加自然(通常也更高效)

> 缺点:
    1. 会导致更多的数据重复,
    2. 如果需要对地址进行修正, 需要修改所有相关的 人员文档.

### `_id` 和 ObjectId

MongoDB 中存储的文档必须有一个 `_id` 键, 这个键的值 __可以是任何类型的__ .  
默认是一个 ObjectId 对象, 在一个集合里面, 每个文档都有唯一的 `_id`, 确保集合里面的所有文档都能被唯一标识.  

##### ObjectId

```js
{"_id" : ObjectId("5792f23d6cca423c020b693a")}
```

ObjectId 是 `_id` 的默认类型. 它设计成轻量型的,不同的机器都能用全局唯一的同一种方法方便地生成它.  
这是 MongoDB 采用 ObjectId, 而不是其他比较常规的做法(比如主键自增) 的原因.  
因为在多个服务器上同步自动增加主键 即费时又费力.

ObjectId __使用 12 字节的存储空间__ , 是一个由 __24个 十六进制数组组成__ 的字符串(每个字节可以存储两个十六进制数字).

> ?? 常常的 ObjectId 是实际存储长度的两倍  

如果快速连续创建多个 ObjectId ,会发现每次只有最后几个数字变化.另外中间几个数字也会变化(如果创建过程停留了几秒).  
这是 ObjectId 的创建方式导致的. ObjectId 的 12 字节按照如下方式生成

```
0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11
--------------|-----------|-------|------------
8位,4字节      | 6位,3字节  | 4位,2字节| 6位,3字节
时间戳         | 机器      | PID    | 计数器
```

__前4个字节__ (8位):   

从标准纪元开始的时间戳, 单位为妙. 这会带来一些有用的属性.  

- 时间戳, 与随后的5字节组合起来, 提供妙级别的唯一性
- 由于时间戳在前, 意味着 ObjectId _大致_ 会按照插入顺序排列.
    - 这对于某些方面很有用,比如将其作为索引提高效率. 但是这是没有保证的, 仅仅是 "大致"
- 这4个字符串也隐含了创建文档的时间, 绝大多数驱动程序都会提供一个方法, 用于 ObjectId 获得这些信息.

因为使用的是当前时间, 很多用户担心服务器进行时钟同步, 服务器间同步时间确实是个好主意, 但这里时间戳的实际值并不重要, 只要它总是不停的增加的

__机器标识__(6位):  
主机标识符,确保不同主机生成不同的 ObjectId, 不产生冲突, 通常是主机名的散列值(hash)

__PID__(4位):  
进程标识,确保同一台机器上并发的多个进程产生的 ObjectId 是唯一的

__自增__(6位):  
前18个位确保了, 同一秒, 不同机器不同进程产生的 id 是唯一的,最后6位是一个自动增加的计数器,确保同一秒产生的 ObjectId 也是不一样的. 一秒最多允许(`256 * 256 * 256 = 16777216`个不同的 ObjectId)

##### 自动生成 `_id`

如果哦插入文档没有 `_id`, 系统会自动帮你创建一个, 可以由 MongoDB 服务器来做这件事,通常在客户端由驱动程序完成.  

很好的体现了 MongoDB 哲学:  
能交给客户端驱动程序的就不要交给服务器来做.  



- - -
